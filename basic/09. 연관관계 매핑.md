# 연관관계 매핑

객체 관계 매핑(ORM)에서 가장 어려운 부분이 바로 객체 연관관계와 테이블 연관관계를 매핑하는 일이다. 즉, __객체의 참조와 테이블의 외래 키를 매핑하는 것__ 이 중요하다.

- 방향(Direction)
  - 단방향
    - 회원 -> 회사 or 회사 -> 회원 둘 중 한쪽만 참조하는 것
  - 양방향
    - 테이블은 항상 양방향이다.

- 다중성(Multiplicity)
  - 다대일(N:1) : 회원(N)이 속한 회사(1)를 조회
  - 일대다(1:N) : 회사(1)가 자기 회원(N)을 조회
  - 일대일(1:1) 
  - 다대다(N:M)

- 연관관계의 주인(owner)
  - 객체를 양방향 연관관계로 만들면 연관관계의 주인을 정해야 한다.

## 연관관계가 필요한 이유

`객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다. - 객체지향의 사실과 오해`

## 다대일 연관관계

- 객체 연관관계
  - 회원이 회사를 조회하는 다대일 연관관계의 경우 회원 필드에는 회사를 참조하고 있는 필드가 존재한다. 반면 회사 엔티티에는 회원을 참조하는 필드가 존재하지 않는다.
- 테이블 연관관계
  - 회원 테이블은 회사의 외래키를 가지고 있어서 서로 조인하여 조회할 수 있다. 따라서 양방향 연관관계이다.

> 객체 연관관계와 테이블 연관관계의 가장 큰 차이
>
> 객체간에 연관관계를 양방향으로 만들고 싶으면 반대쪽에도 참조하는 필드를 추가해야 한다. 결국 연관관계를 하나 더 만들어야 하는데 정확히는 `양방향이 아니라 서로 다른 단방향 관계가 2개`인 것이다.
> 반면, 테이블은 외래 키 하나로 양방향으로 조인할 수 있다.

객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다. 객체는 `참조`를 사용해서 연관된 객체를 찾는다.

## @ManyToOne

테이블은 항상 양방향 연관관계를 가진다. 하지만 객체는 사실상 양방향 연관관계를 가지지 못하고, 비지니스 규칙으로 잘 묶어서 서로 다른 단방향 연관관계를 양방향 처럼 보이게 하는 것이다.

서로 다른 엔티티에서 양방향 연관관계처럼 보이게 하기 위해서는 @ManyToOne or @OneToMany 를 설정해야 한다. (혹은 @OneToOne) 여기서 `연관관계의 주인`을 설정해야하는데, 연관관계의 주인이란
테이블의 외래키를 수정하고 다룰 수 있는 엔티티를 의미한다. 연관관계의 주인은 항상 `@ManyToOne`쪽이 된다. 즉, 테이블에서 실제로 FK 를 가지고 있는 테이블이 연관관계의 주인이 된다.

## 식별관계와 비식별관계

식별관계는 한 테이블의 기본키가 다른 테이블에서 기본키 + 외래키로 사용되는 경우인데, 식별관계를 사용하는 경우 `@IdClass` 난 `@EmbeddedId` 를 사용해야 한다. 식별관계의 복합키를 사용하는 경우보다 비식별관계처럼 인조키를 만들어 사용하는 편이 더 편하다. 

식별관계는 테이블의 기본키를 자식 테이블로 전파하면서 자식 테이블의 기본키 컬럼이 점점 늘어난다. 그리고 식별관계는 2개 이상의 컬럼을 합해서 복합키로 사용하는 경우가 많다.
__식별 관계를 사용할 때 기본 키로 비지니스 의미가 있는 자연 키 컬럼을 조합하는 경우가 많은데, 비지니스는 언제든 변경될 가능성이 있다.__ 따라서, 비식별 관계 처럼 인조키를 만들어 주로 사용한다.

__가급적, 비식별 관계를 사용하고 기본 키는 Long 타입의 대리키를 사용하는 것이다.__ 그리고 선택적 비식별 관계보다는 필수적 비식별 관계를 사용하는 것이 좋다.
선택적 비식별관계는 NULL 을 허용하므로 조인할 때 외부조인을 사용해야 한다. 반면 필수적 비식별 관계는 NOT NULL 이기 때문에 항상 관계가 있다는 것을 보장하므로 내부 조인만 사용해도 된다.

## 양방향 연관관계

> 테이블은 외래 키 하나로 두 테이블의 연관관계를 관리. 객체는 외래키가 아닌 참조를 통해서 연관된 객체를 찾는다.

- 양방향 매핑 규칙
  - 객체의 두 관계중 하나를 연관관계의 주인으로 지정
  - `연관관계의 주인만이 외래 키를 관리(등록, 수정)`
  - `주인이 아닌쪽은 읽기만 가능`
  - 주인은 mappedBy 속성 사용 X 
  - 주인이 아니면 mappedBy 속성으로 주인 지정
  - 연관관계의 주인은 항상 `多` 쪽인 `@ManyToOne`이 된다. 그리고 `One` 쪽이 mappedBy 속성을 사용하는 쪽이 된다.

- 누구를 주인으로?
  - 외래키가 있는 곳을 주인으로 정한다.

![JPA](../basic/images/jpa18.JPG)

### 연관관계의 주인과 mappedBy

> 객체와 테이블의 연관관계를 맺는 차이를 이해해야 한다.

Member 와 Team 이라는 객체가 있다고하면 사실상 회원에서 팀으로가는 단방향 연관관계 1개, 팀에서 회원으로가는 단방향 연관관계 1개 총 2개가 있는 것이다. 즉, 객체를 양방향으로 참조하려면
`단방향 연관관계를 2개`만들어야 한다. 반면, 테이블은 외래키(FK) 하나로 양방향으로 조회가 가능하다.

### 양방향 매핑 시 많이 하는 실수 : `연관관계의 주인에 값을 입력하지 않음`

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setName("member1");

// 역방향(주인이 아닌 방향)만 연관관계 설정
team.getMembers().add(member);

em.persist(member);
```

### 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다. : `순수한 객체 관계를 고려하면 항상 양쪽다 값을 입력해야 한다.`

```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setName("member1");

team.getMembers().add(member); 

//연관관계의 주인에 값 설정
member.setTeam(team); //**

em.persist(member)
```

### 양방향 연관관계 주의

- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
- 연관관계 편의 메소드를 생성하자
- 양방향 매핑시에 무한 루프를 조심하자
  - 예: toString(), lombok, JSON 생성 라이브러리
  - `가급적이면 lombok 을 사용할 때 toString() 은 자제`하는게 좋다. 만약에 Member 와 Team 관계에서 member toString 에서 team 을 호출하면, team 의 toString 을 또 호출하고 무한루프가 발생할 수 있다.
  - JSON 생성 라이브러리도 비슷한데, 결과적으로말하면 `Controller 에서는 절대 Entity 를 반환해서는 안된다.` 왜냐하면 Entity 를 API 스펙에 맞춰 JSON 으로 반환하게되면 무한루프 발생가능성이 있고, 두 번째는 나중에 엔티티를 변경하게 되는 순간 API Spec 이 바뀌어 버리게 된다. Entity 는 DTO 로 변환해서 반환하는것이 좋다.

#### 연관관계 편의 메소드

```java
public class Member {
  // 생략
  
  public void setTeam(Team team) {
    this.team = team;
    team.getMembers().add(this);
  }
}
```

만약에 연관관계 메서드에 비지니스 로직이 결합되어야한다면 메서드 명을 changeTeam 등으로 변경해서 사용하는게 좋다.

### 양방향 매핑 정리

- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
- JPQL 에서 역방향으로 탐색할 일이 많음
- __단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨 (테이블에 영향을 주지 않음)__

### 연관관계의 주인을 정하는 기준

- `비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨`
- `연관관계의 주인은 외래 키의 위치를 기준으로 정해야함`
