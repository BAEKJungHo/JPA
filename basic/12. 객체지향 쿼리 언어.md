# 객체지향 쿼리 언어

- JPQL(Java Persistence Query Language) : `엔티티 객체를 조회하는 객체지향 쿼리`
  - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
  - SQL 을 추상화해서 특정 데이터베이스 SQL 에 의존하지 않는다.
  - JPQL 은 SQL 보다 간결하다. (엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 SQL 보다 코드가 간결하다.)
  - Criteria 나 QueryDSL 은 JPQL 을 편하게 작성하도록 도와주는 빌더 클래스일 뿐이므로 JPQL 이 가장 중요하다.

```java
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```

실제 실행된 SQL

```sql
select 
  member.id as id,
  member.age as age,
  member.team_id as team,
  member.name as name
from 
  Member member
where 
  member.name = 'kim'
```

- Criteria : `JPQL 을 생성하는 빌더 클래스`
  - Criteria 의 장점은 문자가 아닌 query.select(m).where(...) 처럼 프로그래밍 코드로 JPQL 을 작성할 수 있다.
  - 예를들어, JPQL 로 작성한 쿼리에 오류가 있는 경우에는 컴파일 시점에 발견되지 않고, 런타임 시점에 발견된다.
  - JPA 2.0 부터 Criteria 지원
  - 장점
    - 컴파일 시점에 오류를 발견할 수 있다.
    - IDE 를 사용하면 코드 자동완성을 지원한다.
    - 동적 쿼리를 작성하기 편하다.
  - 단점
    - 모든 장점을 상쇄할 정도로 복잡하고 장황하다.
    - 사용하기 불편하고, 가독성이 떨어진다.

```java
// Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

// 쿼리 생성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```

아쉬운 점은 m.get("username") 을 보면 필드 명을 문자로 작성했다. 이 부분도 문자가 아닌 코드로 작성하고 싶으면 `메타 모델(MetaModel)`을 사용하면 된다.

> 메타 모델(MetaModel)
>
> 자바가 제공하는 어노테이션 프로세서 기능을 사용하면 어노테이션을 분석해서 클래스를 생성할 수 있다. JPA 는 이 기능을 사용해서 Member 엔티티 클래스로부터 Member_ 라는 Criteria 전용 클래스를 생성하는데
> 이것을 메타 모델이라고한다.

```
// 메타 모델 사용 전 -> 후
m.get("username") -> m.get(Member_.username)
```
