# 객체지향 쿼리 언어

- __JPQL(Java Persistence Query Language)__ : `엔티티 객체를 조회하는 객체지향 쿼리`
  - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리
  - SQL 을 추상화해서 특정 데이터베이스 SQL 에 의존하지 않는다.
  - JPQL 은 SQL 보다 간결하다. (엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 SQL 보다 코드가 간결하다.)
  - Criteria 나 QueryDSL 은 JPQL 을 편하게 작성하도록 도와주는 빌더 클래스일 뿐이므로 JPQL 이 가장 중요하다.
  - 엔티티를 저장할 때는 EntityManager.persist() 메서드를 사용하면 되므로 INSERT 문은 없다.
  - UPDATE, DELETE 문은 벌크 연산이라고 한다.
  - 엔티티와 속성은 대소문자를 구분한다. 반면 SELECT FROM AS 와 같은 JPQL 키워드는 대소문자를 구분하지 않는다.
  - 별칭(Alias)은 필수 이다. (ex. SELECT m.username FROM Member m)

```java
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```

실제 실행된 SQL

```sql
select 
  member.id as id,
  member.age as age,
  member.team_id as team,
  member.name as name
from 
  Member member
where 
  member.name = 'kim'
```

- __Criteria__ : `JPQL 을 생성하는 빌더 클래스`
  - Criteria 의 장점은 문자가 아닌 query.select(m).where(...) 처럼 프로그래밍 코드로 JPQL 을 작성할 수 있다.
  - 예를들어, JPQL 로 작성한 쿼리에 오류가 있는 경우에는 컴파일 시점에 발견되지 않고, 런타임 시점에 발견된다.
  - JPA 2.0 부터 Criteria 지원
  - 장점
    - 컴파일 시점에 오류를 발견할 수 있다.
    - IDE 를 사용하면 코드 자동완성을 지원한다.
    - 동적 쿼리를 작성하기 편하다.
  - 단점
    - 모든 장점을 상쇄할 정도로 복잡하고 장황하다.
    - 사용하기 불편하고, 가독성이 떨어진다.

```java
// Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

// 쿼리 생성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```

아쉬운 점은 m.get("username") 을 보면 필드 명을 문자로 작성했다. 이 부분도 문자가 아닌 코드로 작성하고 싶으면 `메타 모델(MetaModel)`을 사용하면 된다.

> 메타 모델(MetaModel)
>
> 자바가 제공하는 어노테이션 프로세서 기능을 사용하면 어노테이션을 분석해서 클래스를 생성할 수 있다. JPA 는 이 기능을 사용해서 Member 엔티티 클래스로부터 Member_ 라는 Criteria 전용 클래스를 생성하는데
> 이것을 메타 모델이라고한다.

```
// 메타 모델 사용 전 -> 후
m.get("username") -> m.get(Member_.username)
```

- __QueryDSL__ : JPQL 빌더 역할을 한다. 코드 기반이며 단순하고 사용하기 쉽다.
  - 작성한 코드가 JPQL 과 비슷해서 한눈에 들어온다.
  - JPA 표준은 아니고 오픈소스 프로젝트이다. 이것은 JPA 뿐만 아니라, JDO, Mongo DB, Java Collection, Jucene, Hibernate Search 도 거의 같은 문법으로 지원한다.

```java
// 준비
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

// 쿼리, 결과 조회
List<Member> members = 
  query.from(member)
  .where(member.username.eq("kim"))
  .list(member);
```

- __Native SQL__ : SQL 을 직접 사용할 수 있는 기능
  - JPQL 을 사용해도 특정 데이터베이스에 의존해야하는 기능을 사용해야할 때가 있을때 사용.
    - ex) 오라클의 CONNECT BY 등
  - SQL 은 지원하지만 JPQL 이 지원하지 않는 기능을 사용해야할 때 사용.
  - 단점은 데이터베이스에 의존적이다.

```java
String sql = "SELECT ID, AGE FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```

- __JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용__ : 책 353p

## JPQL

작성한 JPQL 을 실행하려면 쿼리 객체를 만들어야 한다.

- TypeQuery : 반환할 타입을 명확하게 지정할 수 있는 경우
- Query : 반환할 타입을 명확하게 지정할 수 없는 경우
- query.getResultList() : 결과를 반환한다. 결과가 없으면 빈 컬렉션을 반환한다.
- query.getSingleResult() : 결과가 정확히 하나일 때 사용한다.

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);
List<Member> resultList = query.getResultList();
```

```java
Query query = em.createQuery("SELECT m FROM Member m", Member.class);
List resultList = query.getResultList();
for(Object o : resultList) {
  Object[] result = (Object[]) o; // 결과가 둘 이상이면 Object[] 반환
  // 생략
}
```

### 파라미터 바인딩

JDBC 는 `위치 기준 파라미터 바인딩`만 지원하지만 JPQL 은 `이름 기준 파라미터 바인딩`도 지원한다.

#### 이름 기준 파라미터 바인딩(Name Parameters)

```java
String usernameParam = "User1";
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class);
query.setParameter("username", usernameParam);
List<Member> resultList = query.getResultList();
```

- JPQL 의 대부분 API 들은 메서드 체인 방식으로 되어있어서 다음과 같이 작성 할 수 있다.

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class)
                            .setParameter("username", usernameParam);
                            .getResultList();
```

#### 위치 기준 파라미터 바인딩(Positional Parameters)

```java
List<Member> members = em.createQuery("SELECT m FROM Member m where m.username = ?1", Member.class)
                        .setParameter(1, usernameParam)
                        .getResultList();
```

위치 기준 파라미터 바인딩 보다 이름 기준 파라미터 바인딩을 사용하는 것이 더 명확하다.

#### SQL Injection 가능한 파라미터 바인딩 방식

아래 소개되는 바인딩 방식은 절대 사용하면 안된다. 자칫 하다간 SQL Injection 공격을 받을 수도 있다.

```java
"SELECT m FROM Member m WHERE m.username = '" + usernameParam + "'"
```
